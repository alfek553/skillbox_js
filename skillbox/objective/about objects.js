// Объект, объявленный через const, может быть изменён.
// Может показаться, что строка (*) должна вызвать ошибку, но нет, здесь всё в порядке. Дело в том, 
// что объявление const защищает от изменений только саму переменную user, а не её содержимое.

// Определение const выдаст ошибку только если мы присвоим переменной другое значение: user=....
const user = {
    name: "John"
  };
  
  user.name = "Pete"; // (*)
  
  alert(user.name); // Pete
/*-------------------------------------------------------------
*/
  let user = {
    name: "John",
    age: 30,
    "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
  };
/*-------------------------------------------------------------
*/
//   Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
  // это вызовет синтаксическую ошибку
user.likes birds = true

let user = {};
// Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства:
// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
alert(user["likes birds"]); // true
/*-------------------------------------------------------------
*/
// удаление свойства
delete user["likes birds"];
/*-------------------------------------------------------------
*/
// Запись «через точку» такого не позволяет:
let user = {
    name: "John",
    age: 30
  };
  
  let key = "name";
  alert( user.key ); // undefined

/*-------------------------------------------------------------
*/
//   Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.

// Пример:
  let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};

alert( bag.apple ); // 5, если fruit="apple"
/*-------------------------------------------------------------
*/
function makeUser(name, age) {
    return {
      name, // то же самое, что и name: name
      age   // то же самое, что и age: age
      // ...
    };
    let user = makeUser("John", 30);
alert(user.name); // John
  }
/*-------------------------------------------------------------
*/
//   При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства:
let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
// Также существует специальный оператор "in" для проверки существования свойства в объекте.

// Синтаксис оператора:
"key" in object
// Пример:

let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
// Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.

// Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. Например:
let user = { age: 30 };

let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key
/*-------------------------------------------------------------
*/
// Упорядочение свойств объекта
// cвойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, 
// остальные располагаются в порядке создания. Разберёмся подробнее.

// В качестве примера рассмотрим объект с телефонными кодами:
let codes = {
    "49": "Германия",
    "41": "Швейцария",
    "44": "Великобритания",
    // ..,
    "1": "США"
  };
  
  for (let code in codes) {
    alert(code); // 1, 41, 44, 49
  }
//   С другой стороны, если ключи не целочисленные, то они перебираются в порядке создания
  /*-------------------------------------------------------------
*/

/*
Итого
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

Они хранят свойства (пары ключ-значение), где:

Ключи свойств должны быть строками или символами (обычно строками).
Значения могут быть любого типа.
Чтобы получить доступ к свойству, мы можем использовать:

Запись через точку: obj.property.
Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
Дополнительные операторы:

Удаление свойства: delete obj.prop.
Проверка существования свойства: "key" in obj.
Перебор свойств объекта: цикл for for (let key in obj).
То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

В JavaScript есть много других типов объектов:

Array для хранения упорядоченных коллекций данных,
Date для хранения информации о дате и времени,
Error для хранения информации об ошибке.
… и так далее.
У них есть свои особенности, которые мы изучим позже.
Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», 
но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.

Объекты в JavaScript очень мощные. 
Здесь мы только немного углубились в действительно огромную тему. 
Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.
*/